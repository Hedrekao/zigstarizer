const std = @import("std");
const g = @import("geometry.zig");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    if (args.len < 3) {
        std.debug.print("Usage: obj2zig <input_path> <output_path>\n", .{});
        std.process.exit(1);
    }

    const input_path = args[1];
    const output_path = args[2];

    const input = try std.fs.cwd().openFile(input_path, .{});
    defer input.close();

    var faces = std.ArrayList(g.Face).empty;
    defer faces.deinit(allocator);

    var vertices = std.ArrayList(g.V3f).empty;
    defer vertices.deinit(allocator);

    const read_buf = try allocator.alloc(u8, 1024);
    defer allocator.free(read_buf);

    var file_reader = input.reader(read_buf);
    var reader = &file_reader.interface;

    while (try reader.takeDelimiter('\n')) |line| {
        if (line.len == 0) continue;
        var parts = std.mem.splitScalar(u8, line, ' ');
        const indicator = parts.next().?;
        if (std.mem.eql(u8, indicator, "v")) {
            var x = try std.fmt.parseFloat(f32, parts.next().?);
            var y = try std.fmt.parseFloat(f32, parts.next().?);
            var z = try std.fmt.parseFloat(f32, parts.next().?);

            if (z == -0.0) z = 0.0;
            if (y == -0.0) y = 0.0;
            if (x == -0.0) x = 0.0;

            try vertices.append(allocator, g.V3f{ .x = x, .y = y, .z = z });
        } else if (std.mem.eql(u8, indicator, "f")) {
            var face: g.Face = undefined;
            for (0..3) |i| {
                const face_part = parts.next().?;
                var face_iter = std.mem.splitScalar(u8, face_part, '/');
                const vertex_index = try std.fmt.parseInt(u32, face_iter.next().?, 10) - 1;
                switch (i) {
                    0 => face.v1 = vertex_index,
                    1 => face.v2 = vertex_index,
                    2 => face.v3 = vertex_index,
                    else => unreachable,
                }
            }

            try faces.append(allocator, face);
        }
    }

    if (std.fs.path.dirname(output_path)) |dir_path| {
        std.fs.cwd().makePath(dir_path) catch {};
    }

    const output = try std.fs.cwd().createFile(output_path, .{});
    defer output.close();

    const write_buf = try allocator.alloc(u8, 65536);
    defer allocator.free(write_buf);
    var file_writer = output.writer(write_buf);

    var writer = &file_writer.interface;

    try writer.print("// This file is autogenerated by obj2zig.zig\n", .{});
    try writer.print("const g = @import(\"geometry\");\n\n", .{});
    try writer.print("pub const vertices = [_]g.V3f{{\n", .{});
    for (vertices.items) |v| {
        try writer.print("    .{{ .x = {}, .y = {}, .z = {} }},\n", .{ v.x, v.y, v.z });
    }
    try writer.print("}};\n\n", .{});

    try writer.print("pub const faces = [_]g.Face{{\n", .{});
    for (faces.items) |f| {
        try writer.print("    .{{ .v1 = {}, .v2 = {}, .v3 = {} }},\n", .{ f.v1, f.v2, f.v3 });
    }
    try writer.print("}};\n", .{});

    try writer.flush();
}
