const std = @import("std");
const g = @import("geometry.zig");

pub fn main() !void {

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    if (args.len < 3) {
        std.debug.print("Usage: obj2zig <input_path> <output_path>\n", .{});
        std.process.exit(1);
    }

    const input_path = args[1];
    const output_path = args[2];

    const input = try std.fs.cwd().openFile(input_path, .{});
    defer input.close();

    var faces = std.ArrayList(g.Face).empty;
    defer faces.deinit(allocator);

    var vertices = std.ArrayList(g.V3f).empty;
    defer vertices.deinit(allocator);

    const read_buf = try allocator.alloc(u8, 1024);
    defer allocator.free(read_buf);

    var file_reader = input.reader(read_buf);
    var reader = &file_reader.interface;

    while (try reader.takeDelimiter('\n')) |line| {
        if (line.len == 0) continue;
        var parts = std.mem.splitScalar(u8, line[2..], ' ');
        if (line[0] == 'v') {
            var x = try std.fmt.parseFloat(f32, parts.next().?);
            var y = try std.fmt.parseFloat(f32, parts.next().?);
            var z = try std.fmt.parseFloat(f32, parts.next().?);

            if (z == -0.0) z = 0.0;
            if (y == -0.0) y = 0.0;
            if (x == -0.0) x = 0.0;

            try vertices.append(allocator, g.V3f{ .x = x, .y = y, .z = z });
        } else if (line[0] == 'f') {
            const v1_idx = try std.fmt.parseInt(u32, parts.next().?, 10) - 1;
            const v2_idx = try std.fmt.parseInt(u32, parts.next().?, 10) - 1;
            const v3_idx = try std.fmt.parseInt(u32, parts.next().?, 10) - 1;
            try faces.append(allocator, g.Face{ .v1 = v1_idx, .v2 = v2_idx, .v3 = v3_idx });
        }
    }

    if (std.fs.path.dirname(output_path)) |dir_path| {
        std.fs.cwd().makePath(dir_path) catch {};
    }

    const output = try std.fs.cwd().createFile(output_path, .{});
    defer output.close();

    const write_buf = try allocator.alloc(u8, 65536);
    defer allocator.free(write_buf);
    var file_writer = output.writer(write_buf);

    var writer = &file_writer.interface;

    try writer.print("// This file is autogenerated by obj2zig.zig\n", .{});
    try writer.print("const g = @import(\"geometry\");\n\n", .{});
    try writer.print("pub const vertices = [_]g.V3f{{\n", .{});
    for (vertices.items) |v| {
        try writer.print("    .{{ .x = {}, .y = {}, .z = {} }},\n", .{ v.x, v.y, v.z });
    }
    try writer.print("}};\n\n", .{});

    try writer.print("pub const faces = [_]g.Face{{\n", .{});
    for (faces.items) |f| {
        try writer.print("    .{{ .v1 = {}, .v2 = {}, .v3 = {} }},\n", .{ f.v1, f.v2, f.v3 });
    }
    try writer.print("}};\n", .{});

    try writer.flush();
}
